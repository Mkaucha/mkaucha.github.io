---
layout: blogdetail
author: Milan Kaucha
title: Advanced Models
categories: Django
excerpt_separator: <!--more-->
---

Some more advance features of Models in Django.
{% raw %}

#### 1. Accessing ForeignKey values

When we access a field that's a **ForeignKey**, we'll get the related model object.

<pre>
<code>
  >>> b = Book.objects.get(id=50)
  >>> b.publisher
  < Publisher: Apress Publishing >
  >>> b.publisher.website
  'http://www.apress.com/'
</code>
</pre>

With **ForeignKey** fields, it works the other way, too, but it's slightly different due to non-symmetical nature of the relationship.

<pre>
<code>
  # To get a list of books for a given publisher
  >>> p = Publisher.objects.get(name='Apress Publishing')
  >>> p.book_set.all()
  [<Book: The Django Book>, <Book: Dive Into Python>, ...]
</code>
</pre>

Behind the scene, **book_set** is just a **QuerySet**, and it can be filtered and sliced like any other **QuerySet**.

<pre>
<code>
  >>> p = Publisher.objects.get(name='Apress Publishing')
  >>> p.book_set.filter(title__icontains='django')
  [<Book: The Django Book>, <Book: Pro Django>]
</code>
</pre>

> Note:
>
> The attribute name **book_set** is generated by appending the lower case **model name** to \_set.

#### 2. Accessing many-to-many values

Many-to-many values work like foreign-key values, except we deal with **QuerySet** values instead of model instances.

<pre>
<code>
  >>> b = Book.objects.get(id=50)
  >>> b.authors.all()
  [<Author: Adrian Holovaty>, <Author: Jacob Kaplan-Moss>]
</code>
</pre>

It work in reverse, too.

<pre>
<code>
  # To view all of the books for an author
  >>> a = Author.objects.get(first_name='Adrian', last_name='Holvaty')
  >>> a.book_set.all()
  [< Book: The Django Book >, < Book: Adrian's Other Book >]
</code>
</pre>

> Note:
>
> As with **ForeignKey** fields, the attribute name **book_set** is generated by appending lower case **model name** to \_set.

#### 3. Managers

In the statement **Book.objects.all(), objects** is a special attribute through which we query our database. We identified this as model's manager.

In short, a model's manager is an object through which Django models perform database queries. Each Django model has at least one manager, and we can create custom managers in order to customize database access.

There are two reasons we might want to create a custom manager:

1. To add extra manager methods
2. To modify the inital **QuerySet** the manager returns.

##### Adding extra manager methods

Adding extra manager methods is the preferred way to add table-level functionality to your models.

For example, let's give our **Book** model a manager method **title_count()** that takes a keyword and returns the number of books that have a title containing that keyword.

###### models.py

<pre>
<code>
  from django.db import models

  # ... Author and Publisher models here ...#

  class BookManager(models.Manager):
      def title_count(self, keyword):
          return self.filter(title__icontains=keyword).count()

  class Book(models.Model):
      title = models.CharField(max_length=100)
      authors = models.ManyToManyField(Author)
      publisher = models.ForeignKey(Publisher)
      publication_date = models.DateField()
      num_pages = models.IntegerField(blank=True, null=True)
      objects = BookManager()

      def __str__(self):
          return self.title
</code>
</pre>

Here are some notes about the code:

1. We've created a **BookManager** class that extends **django.db.models.Manager**.This has a single method, **title_count()**, which does the calculation. The method uses **self.filter()**, where self refers to the manager itself.

2. We've assigned **BookManager()** to the **objects** attribute on the model. This has the effect of replacing the default manager for the model, which is called **objects** and is automatically created if you don't specify a custom manager.

<pre>
<code>
  >>> Book.objects.title_count('django')
  4
  >>> Book.objects.title_count('python')
  18
</code>
</pre>

##### Modifying initial manager QuerySets

A manager's base **QuerySet** returns all objects in the system. For example, **Book.objects.all()** returns all the books in the book database. We can override a manager's base **QuerySet** by overriding the **Manage.get_queryset()** method. **get_queryset()** should return a **QuerySet** with the properties we require.

The following model has two managers - one that returns all objects, and one that returns only the books by Roald Dahl.

<pre>
<code>
  from django.db import models

  # First, define the Manager subclass
  class DahlBookManager(models.Manager):
      def get_queryset(self):
          return super(DahlBookManager, self).get_queryset().filter(author='Roald Dahl')
  
  # Then hook it into the Book model explicitly.
  class Book(models.Model):
      title = models.CharField(max_length=100)
      author = models.CharField(max_length=50)
      # ...

      objects = models.Manager() # The default manager
      dahl_objects = DahlBookManager() #  The Dahl-specific manager.
</code>
</pre>

> Note:
>
> we explicitly set **objects** to a vanilla Manager instance, because if we hadn't, the only available manager would be **dahl_objects**.

**get_queryset()** returns a QuerySet object, you can use **filter()**, **exclude()** and all the other **QuerySet** methods on it. So these statements are all legal:

<pre>
<code>
  Book.dahl_objects.all()
  Book.dahl_objects.filter(title='Matilda')
  Book.dahl_objects.count()
</code>
</pre>

You can attach as many **Manager()** instances to a model as we'd like. For example, an easy way to define common filters for our models.

<pre>
<code>
  class MaleManager(models.Manager):
      def get_queryset(self):
          return super(MaleManager, self).get_queryset().filter(sex='M')
  
  class FemaleManager(models.Manager):
      def get_queryset(self):
          return super(FemaleManager, self).get_queryset().filter(sex='F')

  class Person(models.Model):
      first_name = models.CharField(max_length=50)
      last_name = models.CharField(max_length=50)
      sex = models.CharField(max_length=1, 
                             choices=(
                               ('M', 'Male'),
                               ('F', 'Female')
                             )
                            )
      people = models.Manager()
      men = MaleManager()
      women = FemaleManager()
</code>
</pre>

> Note:
>
> It's often a good idea to be careful in our choice of default manager, in order to avoid a situation where overriding of **get_queryset()** results in an inabilty to retrieve objects we'd like to work with.

#### 4. Model methods

Custom methods on a model add custom row-level functionality to our objects. Whereas managers are intended to to table-wide things, model methods act on a particular model instance which is a valuable technique for keeping business logic in one place - the model

<pre>
<code>
  from django.db import models

  class Person(models.Model):
      first_name = models.CharField(max_length=50)
      last_name = models.CharField(max_length=50)
      birth_date = models.DateField()

      def baby_boomer_status(self):
          """Returns the person's baby-boomer status."""
          if self.birth_date < datetime.date(1994, 8, 1):
              return "Pre-boomer"
          elif self.birth_date < datetime.date(1965, 1, 1):
              return "Baby boomer"
          else:
              return "Post-boomer"
      
      def _get_full_name(self):
          """Returns the person's full name."""
          return '%s %s' % (self.first_name, self.last_name)
      full_name = property(_get_full_name)
</code>
</pre>

Many methods are automatically given to each model. We can override most of these but some of us we'll almost always want to define:

1. **\_\_str\_\_()**: A python magic method that returns a Unicode representation of any object. This is what Python and Django will use whenever a model instance needs to ve coerced and displayed as a plain string.

2. **get_absolute_url()** : This tells Django how to calculate the URL for an object. Django uses this in its admin interface, and any time it needs to figure out a URL for an object.

##### Overriding predefined model methods

There's another set of model methods that encapsulate a bunch of databasee behavior that we'll want to customize. We're free to override **save()** and **delete()** methods if we want to change the way it works.

A classic use-case for overriding the built-in methods as if something to happen whenever we save an object.

<pre>
<code>
  from django.db import models

  class Blog(models.Model):
      name = models.CharField(max_length=100)
      tagline = models.TextField()

      def save(self, *args, **kwargs):
          do_something()
          super(Blog, self).save(*args, **kwargs) # Call the "real" save() method.

          do_something_else() 

  # Prevent Saving:

  from django.db import models

  class Blog(models.Model):
      name = models.CharField(max_length=100)
      tagline = models.TextField()

      def save(self, *args, **kwargs):
          if self.name == "Yoko Ono's blog":
              return # Yoko shall never have her own blog!
          else:
              super(Blog, self).save(*args, **kwargs) # Call the "real" save() mehtod.
</code>
</pre>

It's important to remember to call the superclass method - that's **super(Blog, self).save(\*args, \*\*kwargs)** - to ensure that the object still gets saved into the database.

##### Executing raw SQL queries

When the model query APIs don't go far enough, we can fall back to writting raw SQL. Django provides two ways of performing raw SQL queries:

1. Use **Manager.raw()**

2. Executer custom SQL directly.

> Note:
>
> Every time we use raw SQL, we should properly escape any prameters that the user can control by using **params** in order to protect against SQL injection attacks.

#### 5. Performing raw queries

The **raw()** manager method can be used to perform raw SQL queries that return model instances:

<pre>
<code>
  Manager.raw(raw_query, params=None, translation=None)
</code>
</pre>

This method takes a raw SQL query, executes it, and returns a **djanog.db.models.query.RawQuerySet** instace. The **RawQuerySet** instance can be iterated over just like a normal **QuerySet** to provide object instances.

<pre>
<code>
  class Person(models.Model):
      first_name = models.CharField(...)
      last_name = models.CharField(...)
      birth_date = models.DateField(...)

  >>> for p in Person.objects.raw('SELECT * FROM myap_person'):
  ...     print(p)
  John Smith
  Jane Jones
</code>
</pre>

##### Mapping query fields to model fields

**raw()** automatically maps fields in the query to fields on the model. The order of fields in our query doen't matter.

<pre>
<code>
  >>> Person.objects.raw('SELECT id, first_name,last_name, birth_date FROM myapp_person')
  ...
  >>> Person.objects.raw('SELECT last_name, birth_date, first_name, id FROM myapp_person')
  ...
</code>
</pre>

##### Index lookups

**raw()** supports indexing,

<pre>
<code>
  >>> first_person = Person.objects.raw('SELECT * FROM myapp_person')[0]

  # Indexing and slicing are not performed at database leve.
  # It is more efficient to limit the query at the SQL lever.

  >>> first_person = Person.objects.raw('SELECT * FROM myapp_person LIMIT 1')[0]
</code>
</pre>

##### Deferring model fields

Fields may also be left out:

<pre>
<code>
  >>> people = Person.objects.raw('SELECT id, first_name FROM myapp_person')

  # The person objects returned by this query will be differed model instances.
  # This means that the fields that are ommited from the query will be loaded on demand.

  >>> for p in Person.objects.raw('SELECT id, first_name FROM myapp_person'):
  ...     print(p.first_name, # This will be retrieved by the original query
                p.last_name)  # This will be retrieved on demand
  John Smith
  Jane Jones 
</code>
</pre>

##### Adding annotations

We can also execute queries containing fields that aren't defined on the model.

<pre>
<code>
  >>> people = Person.objects.raw('SELECT *, age(birth_date) AS age FROM myapp_person')
  >>> for p in people:
  ...     print("%s is %s." % (p.first_name, p.age))
  John is 37.
  Jane is 42.
</code>
</pre>

##### Passing parameters into raw()

if we need to perform parameterized queries, we can pass the params argument to **raw()**:

<pre>
<code>
  >>> lname = 'Doe'
  >>> Person.objects.raw('SELECT * FROM myapp_person WHERE last_name = %s', [lname])
</code>
</pre>

**params** is a list or dictionary of parameters. You'll use **%s** placeholders in the query string for a list, or **%(key)s** placeholders for a dictionary (where key is replaced by a dictionary key, of course)

> Note:
>
> Using the **params** argument completely protects you from **SQL injection** attacks, a common exploit where attackers inject arbitrary SQL into your database. If you use string interpolation, sooner or later you'll fall victim to SQL injection.

#### 6. Executing custom SQL directly

Sometimes even **Manager.raw()** isn't quite enough: we might need to perform queries to directly execute **UPDATE, INSERT, or DELETE** queries.

We can always access the database directly, routing around the model layer entirely.

The object **django.db.connection** represents the default database connection. To use the database connection, call **connection.cursor()** to get a cursor object. Then call **cursor.execute(sql, [params])** to execute the SQL and **cursor.fetchone()** or **cursor.fetchall()** to return the resulting rows.

<pre>
<code>
  from django.db import connection

  def my_custom_sql(self):
      cursor = connection.cursor()
      cursor.execute("Update bar SET foo = 1 WHERE baz = %s", [self.baz])
      cursor.execute("SELECT foo FROM bar WHERE baz = %s", [self.baz])
      row = cursor.fetchone()

      return row
</code>
</pre>

If we want to include **literal percent** signs in the query, we have to **double** them in the case we are passing parameters:

<pre>
<code>
  cursor.execute("SELECT foo FROM bar WHERE baz = '30%'")
  cursor.execute("SELECT foo FROM bar WHERE baz = '30%%' AND id = %s", [self.id])
</code>
</pre>

if we are using more than one database, we can use **django.db.connections** to obtain the connection (and cursor) for a specific database. **django.db.connections** is a dictionary-like object that allows us to retrieve a specific connection using its alia:

<pre>
<code>
  from django.db import connections
  cursor = connections['my_db_alias'].cursor()
  # Your code here ..
</code>
</pre>

{% endraw %}
