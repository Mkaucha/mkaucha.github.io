---
layout: blogdetail
author: Milan Kaucha
title: Advanced Models
categories: Django
excerpt_separator: <!--more-->
---

Some more advance features of Models in Django.
{% raw %}

#### 1. Accessing ForeignKey values

When we access a field that's a **ForeignKey**, we'll get the related model object.

<pre>
<code>
  >>> b = Book.objects.get(id=50)
  >>> b.publisher
  < Publisher: Apress Publishing >
  >>> b.publisher.website
  'http://www.apress.com/'
</code>
</pre>

With **ForeignKey** fields, it works the other way, too, but it's slightly different due to non-symmetical nature of the relationship.

<pre>
<code>
  # To get a list of books for a given publisher
  >>> p = Publisher.objects.get(name='Apress Publishing')
  >>> p.book_set.all()
  [<Book: The Django Book>, <Book: Dive Into Python>, ...]
</code>
</pre>

Behind the scene, **book_set** is just a **QuerySet**, and it can be filtered and sliced like any other **QuerySet**.

<pre>
<code>
  >>> p = Publisher.objects.get(name='Apress Publishing')
  >>> p.book_set.filter(title__icontains='django')
  [<Book: The Django Book>, <Book: Pro Django>]
</code>
</pre>

> Note:
>
> The attribute name **book_set** is generated by appending the lower case **model name** to \_set.

#### 2. Accessing many-to-many values

Many-to-many values work like foreign-key values, except we deal with **QuerySet** values instead of model instances.

<pre>
<code>
  >>> b = Book.objects.get(id=50)
  >>> b.authors.all()
  [<Author: Adrian Holovaty>, <Author: Jacob Kaplan-Moss>]
</code>
</pre>

It work in reverse, too.

<pre>
<code>
  # To view all of the books for an author
  >>> a = Author.objects.get(first_name='Adrian', last_name='Holvaty')
  >>> a.book_set.all()
  [< Book: The Django Book >, < Book: Adrian's Other Book >]
</code>
</pre>

> Note:
>
> As with **ForeignKey** fields, the attribute name **book_set** is generated by appending lower case **model name** to \_set.

#### 3. Managers

In the statement **Book.objects.all(), objects** is a special attribute through which we query our database. We identified this as model's manager.

In short, a model's manager is an object through which Django models perform database queries. Each Django model has at least one manager, and we can create custom managers in order to customize database access.

There are two reasons we might want to create a custom manager:

1. To add extra manager methods
2. To modify the inital **QuerySet** the manager returns.

##### Adding extra manager methods

Adding extra manager methods is the preferred way to add table-level functionality to your models.

For example, let's give our **Book** model a manager method **title_count()** that takes a keyword and returns the number of books that have a title containing that keyword.

###### models.py

<pre>
<code>
  from django.db import models

  # ... Author and Publisher models here ...#

  class BookManager(models.Manager):
      def title_count(self, keyword):
          return self.filter(title__icontains=keyword).count()

  class Book(models.Model):
      title = models.CharField(max_length=100)
      authors = models.ManyToManyField(Author)
      publisher = models.ForeignKey(Publisher)
      publication_date = models.DateField()
      num_pages = models.IntegerField(blank=True, null=True)
      objects = BookManager()

      def __str__(self):
          return self.title
</code>
</pre>

Here are some notes about the code:

1. We've created a **BookManager** class that extends **django.db.models.Manager**.This has a single method, **title_count()**, which does the calculation. The method uses **self.filter()**, where self refers to the manager itself.

2. We've assigned **BookManager()** to the **objects** attribute on the model. This has the effect of replacing the default manager for the model, which is called **objects** and is automatically created if you don't specify a custom manager.

<pre>
<code>
  >>> Book.objects.title_count('django')
  4
  >>> Book.objects.title_count('python')
  18
</code>
</pre>

##### Modifying initial manager QuerySets

A manager's base **QuerySet** returns all objects in the system. For example, **Book.objects.all()** returns all the books in the book database. We can override a manager's base **QuerySet** by overriding the **Manage.get_queryset()** method. **get_queryset()** should return a **QuerySet** with the properties we require.

The following model has two managers - one that returns all objects, and one that returns only the books by Roald Dahl.

<pre>
<code>
  from django.db import models

  # First, define the Manager subclass
  class DahlBookManager(models.Manager):
      def get_queryset(self):
          return super(DahlBookManager, self).get_queryset().filter(author='Roald Dahl')
  
  # Then hook it into the Book model explicitly.
  class Book(models.Model):
      title = models.CharField(max_length=100)
      author = models.CharField(max_length=50)
      # ...

      objects = models.Manager() # The default manager
      dahl_objects = DahlBookManager() #  The Dahl-specific manager.
</code>
</pre>

> Note:
>
> we explicitly set **objects** to a vanilla Manager instance, because if we hadn't, the only available manager would be **dahl_objects**.

**get_queryset()** returns a QuerySet object, you can use **filter()**, **exclude()** and all the other **QuerySet** methods on it. So these statements are all legal:

<pre>
<code>
  Book.dahl_objects.all()
  Book.dahl_objects.filter(title='Matilda')
  Book.dahl_objects.count()
</code>
</pre>

You can attach as many **Manager()** instances to a model as we'd like. For example, an easy way to define common filters for our models.

<pre>
<code>
  class MaleManager(models.Manager):
      def get_queryset(self):
          return super(MaleManager, self).get_queryset().filter(sex='M')
  
  class FemaleManager(models.Manager):
      def get_queryset(self):
          return super(FemaleManager, self).get_queryset().filter(sex='F')

  class Person(models.Model):
      first_name = models.CharField(max_length=50)
      last_name = models.CharField(max_length=50)
      sex = models.CharField(max_length=1, 
                             choices=(
                               ('M', 'Male'),
                               ('F', 'Female')
                             )
                            )
      people = models.Manager()
      men = MaleManager()
      women = FemaleManager()
</code>
</pre>

{% endraw %}
